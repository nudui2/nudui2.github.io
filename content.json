[{"title":"多客户端使用hexo方案","date":"2017-05-10T02:57:16.000Z","path":"2017/05/10/hexo搭建/","text":"痛点1hexo搭建在本机，单一客户端编辑固然ok，然不方便在多台终端中同时使用。 方案 1，选取云服务器作为中心服务器，此服务器上安装hexo并配置好github账号。 2，在github上创建项目“_posts”，将其pull到hexo的source目录下。 3，在服务器中通过脚本，每15min执行如下操作: 12341，github上pull最新_posts。2，hexo clean3，hexo g4，hexo d 4，每个客户端都将_post项目pull在本机，每次书写玩md直接提交即可。 注意1第三步中的脚本书写，最好能加入一个running的标记，以防crontab的定时任务与手动部署冲突","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"搭建gitlab","date":"2016-12-17T15:32:43.000Z","path":"2016/12/17/搭建gitlab/","text":"搭建gitlab参见https://www.gitlab.cc/downloads/#centos6","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"ssh免密","date":"2016-12-03T16:00:50.000Z","path":"2016/12/04/ssh免密/","text":"ssh免密登录 将本地.ssh目录下的id_rsa.pub文件内容拷贝。 远程登录，到相应的.ssh目录下，将1中内容拷贝至authorized_keys中。 注 chmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys 测试本机，ssh git@1.1.1.1 搭建githttps://segmentfault.com/a/1190000002729796#articleHeader7","tags":[{"name":"jack","slug":"jack","permalink":"http://yoursite.com/tags/jack/"},{"name":"ssh","slug":"ssh","permalink":"http://yoursite.com/tags/ssh/"}]},{"title":"服务端开发的一些小问题","date":"2016-11-25T17:39:57.000Z","path":"2016/11/26/服务端开发的一些小问题/","text":"问题Q：接口一般规则A：参照：http://nudui.github.io/2015/05/16/api%E6%8E%A5%E5%8F%A3%E8%A7%84%E5%88%99/ Q：如何保持会话,登录时到底发生了神马A：不建议使用httpsession，如果用httpsession，则须做好session共享策略。我的方案：http://nudui.github.io/2015/05/16/app%E4%BC%9A%E8%AF%9D%E6%96%B9%E6%A1%88/ 标注一下：这个方案不是我原创，是跟一老大哥学的，消化了好一阵时间。（不过，当我消化了这个方案，这应该就算是我的了吧） Q：如果有人刷我的接口肿么办A：最近我刚刷了一个场子不小的app的短信验证码接口，详情 及 解决办法 请看如下：http://blog.csdn.net/z744760295/article/details/53345113 Q：选用云存储还是自存储A：前期建议选用云存储，云存储平台都会有免费额度。七牛云提供10G空间，100万次GET请求；阿里云提供5G，请求次数也不会太低，团队初期足够了。 Q：那如果有一天leader要求存储必须自有化，那已在db中存储的云资源uri怎么办A：使用云存储之前，就必须得考虑好这个问题，七牛和ali都提供自定义域名服务，在自己的域名下做配置，这样图片uri就是通过自有域名进行资源定位。此时，将云中有用的图片下载，根据路径进行文件服务器配置即可。这样，原存储云的文件就可以转入自有服务器，且uri不会改变。 Q：如果我想一直使用云，某天10G空间不够了怎么办A：我这有个投机取巧的办法：如果某天在七牛上的空间已经使用85%，这时就着手再申请一个账号好了，在服务端代码中改一下七牛的配置，切换到第二个账号，这不就ok了吗，原uri不必去管，反正七牛也不会删掉（七牛也不知道这两个账号有啥关联），不过在第二个账号绑定域名时，还是再开一个子域名比较好，不要对第一个账号的资源进行侵扰。 Q：如果某天七牛发现我的小聪明，把我封掉怎么办A：无论是哪个云，在封号前必定多方联络你，这时可把那些云图片资源取出，再放入其他的云，执行同样的策略。 Q：如果其他的云也封怎么办，不能一直这样下去啊A：上述策略，都是为了省！省！省！省，则必定有一些荆棘。不过，就算是这个云把你封掉，也不见得就没办法。【微博】或者其他大sns，它肯定不会删图片，它还开放了各种接口，咱们可以把微博变成我们的图片服务器，这样不就好了吗。微博的水印问题，网上能找到设置方法。不过，把微博改成自己的文件服务器，是不是挺cool的。 Q：短信接口都有验证码条数限制，这个也能有对策吧A：没错，这个策略与云存储方案类似。单个短信平台对于验证码会有单独的限制，从3条/h ~ 7条/h 不等，我在做app的时候，也会遇到这个问题，产品要求必须每小时能发8条，打电话给短信客服，确实是可以增加。但是，总觉着不舒服，于是有了以下的方案：在阿里大鱼上申请两个（或多个）账号，短信签名全部一致（不要质疑短信平台是否会允许，亲测有效，反馈给阿里大鱼，人家说没遇到过这种情况，也就默许了）。之后再代码中，只要第一个账号发送失败，就走第二个账号。 当然，如果不嫌麻烦，也可以使用多个不同平台的方式，只是每个平台的接口都不一样。使用单平台多账号，好处是扩展方便，不用改多少代码。 Q：app版本控制怎么玩A：看到网上好多人说单独开一个接口，判断是否需要更新app。这个方案还可以吧，只是需要移动端每次打开app时请求服务端，略有些麻烦。其实大可不必，服务端完全不需要开辟单独接口：移动每次与服务端交互，服务端在header中能获取这个请求的具体版本号，缓存必须更新的版本号的value，在拦截器中计算这个版本号的value，看看是否需要强制更新，如果需要，则在拦截器阶段就返回错误码给app，app根据错误码进行提示、下载。这个方案的好处是，无须移动开发人员做太多，覆盖面广，网上的方案只有在特定某个动作触发校验，我的方案是全局校验。 Q：有的app（回家吃饭app），换了个账号登录，竟然收到了原账号的消息，这咋回事A：‘回家吃饭’这个app，业务真的不错，不过它确实有那个问题（八月份的时候）。 先来说说这是怎么发生的：app登录后，会将devicetoken发送给服务端，服务端将devicetoken与用户id进行绑定（允许一个账号多点登录），这样每次需要push的时候，就可以根据devicetoken进行定向push。那为什么会收到原账号的push呢，因为只 做了bind，没做unbind ，‘回家吃饭’没考虑 app不重新下载而换号登录 的问题（重新下载app时，devicetoken会发生变化）！ 怎么解决：退出登录时服务端必须解绑相应的devicetoken。 注： 本人水平有限","tags":[{"name":"app","slug":"app","permalink":"http://yoursite.com/tags/app/"},{"name":"api","slug":"api","permalink":"http://yoursite.com/tags/api/"},{"name":"接口规则","slug":"接口规则","permalink":"http://yoursite.com/tags/接口规则/"}]},{"title":"刷某体育票务app短信验证码接口-接口安全考究","date":"2016-11-25T15:03:43.000Z","path":"2016/11/25/刷app短信接口-接口安全考究/","text":"观察某体育票务app的接口结构此app内有某语言大神，余心诚向往，隐去app名讳。短信接口如下： 圈1： 参数s：应该是对url进行签名 参数t：时间戳 参数mobile：接收短信验证码的手机 http/1.1 : http协议 圈2： cookie：该团队应该是原做web，习惯于cookie、session的模式（当然，这个路子是正确的，只是这个名字…暴露了自己的历史包袱）。在app中通过在header中添加参数来实现。此处与本题无关。 圈3： ChannelId：一个对于业务相关的参数，无甚可说。 token：应该是对设备的唯一标识吧。应该不是auth，毕竟还没登录，何来auth。 从上可知，模拟这个【发送短信验证码】请求，最多需要这么几个参数即可。笔者用postman实践，cookie可以不用管它（话说，这个cookie真的有价值吗？），传不传都无所谓。参数t，对方只用于签名算法。 综上，需要参数s、t、参数mobile、参数Channel（放在header中）、参数token（放在header中）。 模拟开始某月24日： 诸位应当看到，笔者已经告知对方（通过一个多余的参数“tip”），该接口（或者整个app的所有接口），都有可能被模拟，希望对方能够进行修改。注：笔者手机号也在区间内，收到了通过程序发送的短信验证码。 次日： 对方完全任由刷。 模拟后话 次日的再次模拟，依然请求成功（笔者的手机号在此序列）。 对方将笔者ip做了特殊处理（此项排除，笔者手机收到了验证码）。 对方没有看到相应日志，没有发现接口已经被模拟。（不太可能，毕竟不是小team，就算是小team，也早该发现） 对方没有看到tip参数，没有在日志中记录收到的全部参数。（感觉还是不可能，都不是小作坊，我这一个岗位一个人的小摊子还会注意到这点。。） 原因究竟是什么呢？ 结语 笔者毕业三年，路已偏歪，没在大型厂子待过。 可能笔者的整篇文章会见笑于大方家（大神甲：这年轻人太嫩，自以为破解了这个app，其实。。） 不是hacker（水平真的达不到，差的不是一点），却心向往之。 个人对于接口安全的方案（方案师承毕业时的团队）：http://nudui.online/2015/05/16/api接口规则/。 求明白人告诉我，我这到底是不是班门弄斧。","tags":[{"name":"app","slug":"app","permalink":"http://yoursite.com/tags/app/"},{"name":"api","slug":"api","permalink":"http://yoursite.com/tags/api/"},{"name":"接口规则","slug":"接口规则","permalink":"http://yoursite.com/tags/接口规则/"}]},{"title":"beego(01)","date":"2016-11-21T08:52:21.000Z","path":"2016/11/21/beego-01/","text":"startget beego : https://my.oschina.net/ichendong/blog/761467 gov docs : https://beego.me sublimemac环境下快速启动工作目录 123rm /usr/local/bin/sublln -s \"/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl\" /usr/local/bin/subl 在 ~/ 目录下创建.sh 1vim work_hello.sh work_hello.sh ：12#!/bin/bashsubl /Users/jack/gopath/src/hello 对该sh赋予执行权限 1chmod 777 work_hello.sh 开始工作 12cd./work_hello.sh 自动在sublime中打开工作空间。如有多个工作空间，则在~/目录下创建多个sh即可","tags":[{"name":"beego","slug":"beego","permalink":"http://yoursite.com/tags/beego/"}]},{"title":"mac安装beego","date":"2016-11-20T21:56:20.000Z","path":"2016/11/21/mac安装beego/","text":"由于按照谢孟军git上的说明，安装出现各种错误： cannot download, $GOPATH not set. For more details see: go help gopath liteide GolangFmt: Could not find go env 其他导致ide出现问题的错误 几经周折，安装如下：https://my.oschina.net/ichendong/blog/761467","tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"}]},{"title":"golang笔记-5-数据","date":"2016-11-18T02:22:41.000Z","path":"2016/11/18/golang笔记-5-数据/","text":"字符串字符串为不可变字节（byte）序列，是符合结构。 1234type stringStruct struct&#123; str unsafe.Pointer len int&#125; 头部指针指向数组，无NULL结尾，默认为UTF-8存储Unicode字符。 len返回的是数组的字节长度。 123456789func main()&#123; s := \"a\" fmt.Println(s[0]) // 97 fmt.Println(&amp;s[0]) // 报错：cannot take the address of s[0] s = s + \"b\" fmt.Println(s &gt; \"aa\") //true&#125; 字符串遍历12345678910func main()&#123; s := \"受命于天\" for i := 0; i &lt; len(s); i++ &#123; fmt.Println(s[i]) //输出其byte ， 4 * 3 = 12 个字节 &#125; for index, val := range s &#123; fmt.Println(index, val) //输出每个汉字 &#125;&#125; 修改字符串要求改字符串，须将其转换为可变类型（[ ]rune 或者 [ ]byte），修改之后再转回来。但，不管如何转换，都必定重新分配内存并复制数据。","tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"}]},{"title":"golang笔记-4-函数","date":"2016-11-17T15:14:54.000Z","path":"2016/11/17/golang笔记-4-函数/","text":"定义结构化最小模块单元，将复杂的算法过程分解为若干个较小任务，这些认为可在多处复用。函数是一等公民 无须前置声明。（未解其意，何谓“前置声明”） 不支持命名嵌套定义。（未解其意，何谓“命名嵌套定义”） 不支持同名函数重载。 不支持默认参数。（哪些语言的函数有默认参数，未解其意） 支持不定长变参。 支持多返回值。 支持命名返回值。 支持匿名函数与闭包 123456789101112func hello()&#123; fmt.Println(\"hello world\")&#125;func exec(f func())&#123; //函数作为参数 f()&#125;func main()&#123; h := hello exec(h)&#125; 函数只能判断是否为nil，不能判断其他 123456789101112func a ()&#123;&#125;func b()&#123;&#125;func main()&#123; fmt.Println(a == nil) // 输出 false fmt.Pringln(a == b) //报错，无效操作&#125; 参数 无论是指针、引用类型还是其他类型参数，都是值传递。区别无非是拷贝目标对象还是拷贝指针。在函数内对参数进行操作，都不会影响原值。 在函数调用前，会为形参和返回值分配内存空间，并将实参拷贝到形参的内存上。 变参变参实际上是一个切片。只能接收同类型参数","tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"}]},{"title":"golang笔记-3-表达式","date":"2016-11-17T11:06:22.000Z","path":"2016/11/17/golang笔记-3-表达式/","text":"关键字25个关键字12345break continue, if else , go chan , var const type for range , go goto defer , switch case default fallthroughpackage import , func struct return map select 流程控制if .. else .. 表达式的值必须是bool类型。 表达式可以执行初始化语句。如下 : 123456789101112var x int func xinit()&#123; x = 1000&#125;func main()&#123; if xinit(); x &gt; 100&#123; ... // 可以执行 &#125; ...&#125; switch case无须break，自动在相应的case处执行完毕中断 一般形式 123456789101112func main()&#123; a , b , c := 0 , 1 , 2 switch x &#123; case a , b : fmt.Println(\"0 或者 1\") case 4 : fmt.Println(\"值为4\") default : fmt.Println(\"default value\") &#125;&#125; 表达式形式 123456789101112func main()&#123; a , b , c := 0 , 1 , 2 switch x := 100 ; x &#123; case a , b : fmt.Println(\"0 或者 1\") case 4 : fmt.Println(\"值为4\") default : fmt.Println(\"default value\") &#125;&#125; fallthrough 必须放在case块的末尾 123456789101112131415161718func main()&#123; switch x := 100 ; x &#123; case a , b : fmt.Println(\"0 或者 1\") case 100 : x += 10 fmt.Println(x) fallthrough //无条件执行下一个case，default除外。 case 101 : x += 10 fmt.Println(x) //如果还有fallthrough，则继续执行下一个非default的case default : fmt.Println(\"default value\") &#125;&#125; 注意： 不能出现重复的case。 有时switch可代替if语句。 for golang中只有for这一种循环。 for循环完成了java中的while循环、for..each循环。 1234//普通for循环for i := 0 ; i &lt; 100 ; i ++ &#123; ...&#125; 1234//相当于while循环for x &lt; 10 &#123; ... &#125; 1234//相当于while truefor &#123; ...&#125; for range 用于数据迭代，支持字符串、数组、数组指针、切片、字典、通道类型、键值数据 12345678func main()&#123; data := [10]int&#123;1, 2, 3, 4 &#125; for index , v := range data&#123; fmt.Print(\"index is \" + index) fmt.Println(\"value is \" + v) &#125;&#125;","tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"}]},{"title":"大神 on Git","date":"2016-11-17T06:02:11.000Z","path":"2016/11/17/大神-on-Git/","text":"赵烨 java 《轻松学算法》。 https://github.com/irfen http://irfen.me 无闻 golang GIT：https://github.com/Unknwon 谢孟军 《Go Web编程》、beego的作者 https://github.com/astaxie http://edu.51cto.com/lecturer/index/user_id-6177767.html 郝林 《Go并发编程实战》作者 https://github.com/g0hacker","tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/资源/"}]},{"title":"Books on Git","date":"2016-11-17T05:41:11.000Z","path":"2016/11/17/Books-on-Git/","text":"Go入门指南 https://github.com/nudui/the-way-to-go_ZH_CN Go Web编程 https://github.com/astaxie/build-web-application-with-golang/tree/master/zh 雨痕大神 https://github.com/qyuhen/book 国外资料整理 https://github.com/dariubs/GoBooks#web-development","tags":[{"name":"资源","slug":"资源","permalink":"http://yoursite.com/tags/资源/"}]},{"title":"golang笔记-2-指针","date":"2016-11-16T18:42:55.000Z","path":"2016/11/17/golang笔记-2-指针/","text":"指针与内存不能将指针与内存地址混为一谈。 内存地址：每个内存字节单元的唯一编号。 指针：专门用来保存地址的整形（整形？因为一切皆可用数字表示吗）变量。 如图： 表达式 p := &amp;x x := 100 memory 0x1200 100 address 0x800 0x1200 &amp;与*： 取址运算符：&amp; ， 用于获取对象地址。 指针运算符：* ， 用于间接引用目标对象。 123456func main()&#123; x := 10 p := &amp;x fmt.Println(p) // 0xc42000a298 fmt.Println(*p) // 10&#125; 指针运算 支持相等运算。 不支持加减运算、类型转换。 如果两个指针指向同一个地址，则二指针相等","tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"},{"name":"存疑","slug":"存疑","permalink":"http://yoursite.com/tags/存疑/"}]},{"title":"golang笔记-1-类型","date":"2016-11-16T07:06:29.000Z","path":"2016/11/16/golang笔记-1-类型/","text":"命名Go语言强制了编码风格。 任何需要对外暴露的名字必须以大写字母开头，不需要对外暴露的则应该以小写 字母开头。 Go语言明确宣告了拥护骆驼命名法而排斥下划线法。 “{}”，左括号禁止单开一行。gotool中包含了一个代码格式化的功能。命令：go fmt hello.go，自动格式化。 布尔类型 略过 基本数据类型 类型 取值 int8 -128~127 int16 -32768~32767 int32 -2147483648~2147483647 int64 -9223372036854775808~9223372036854775807 uint… 非负数，与上述对应 uint8:0~255 float32 +- 1e-45 -&gt; +- 3.4 * 1e38 float64 +- 5 1e-324 -&gt; 107 1e308 引用类型特指 slice、map、channel 变量局部变量不允许只声明不使用! 12345678910//正确的声明var x intvar x int = 3var x = 3var&#123; x = 3 y = 4&#125;x := 3 //仅限于在函数中。x , y := 3 , 4 123456func x() &#123; var x = 3 x := 3 //错误，:=用于声明 + 赋值 ，x已经声明过了，不能再次声明 ， 只能赋值。 x , y := 1 , 4 //正确 ， y为新变量，此时:=对于x降级为赋值。必须有至少一个新的变量方可。&#125;//退化赋值的前提条件：至少有一个新的变量被定义，且必须是同一作用域。 1234var x = 3func x()&#123; x := 4 //正确，此时的x与函数外的x作用域不同，相当于一个新的变量。&#125; 多变量在进行多变量赋值时，先计算右侧的所有值，然后完成赋值操作。 12345func main()&#123; a , b := 1 , 2 a , b = a + 1 : b + 1 fmt.Println(a , b) //结果：2 ，3&#125; 12345678func exchange(a , b int) (int,int)&#123; a , b = b , a return a , b&#125;func main()&#123; //只想使用b _ , b = exchange(1 , 2)&#125; 常量运行时恒定不变的，编译期间能确定值！可在函数内定义，允许只定义不使用。 12显式类型定义： const b string = \"abc\"隐式类型定义： const b = \"abc\" 12正确的做法：const c1 = 2/3错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() used as value 字符类型严格来说这并非go语言的一个类型，字符只是证书的特殊用例。byte 类型是 uint8 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题。 例如：var ch byte = &#39;A&#39;字符使用单引号括起来。 1234判断是否为字母：unicode.IsLetter(ch)判断是否为数字：unicode.IsDigit(ch)判断是否为空白符号：unicode.IsSpace(ch)这些函数返回一个布尔值。 字符串字符串是UTF-8的一个序列（当字符为ASCII码时占一个字节，其他字符需要2-4个字节）。","tags":[{"name":"golang","slug":"golang","permalink":"http://yoursite.com/tags/golang/"}]},{"title":"tomcat加载两次spring","date":"2016-07-16T07:57:16.000Z","path":"2016/07/16/tomcat加载两次spring/","text":"1，为了达到通过ip：端口进行访问 ，做了如下配置： 2，然而，host标签加载一次webapps里面的项目 ， context标签加载一次docbase的项目，于是造成了两次加载。3，解决办法：在host标签加一个 deployIgnore=”.项目名.“ ， 这样，host就不会加载。","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"},{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"}]},{"title":"让mysql支持表情","date":"2016-06-16T08:00:57.000Z","path":"2016/06/16/让mysql支持表情/","text":"修改 /etc/my.cnf1234567891011[client] default-character-set = utf8mb4[mysql] default-character-set = utf8mb4&lt;!--more--&gt;[mysqld] character-set-client-handshake = FALSE character-set-server = utf8mb4 collation-server = utf8mb4_unicode_ci init_connect='SET NAMES utf8mb4' 代码中tomcat 6 + 、jetty 6 + 均在内部支持emoji，无须做任何代码上的修改即可","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"emoji","slug":"emoji","permalink":"http://yoursite.com/tags/emoji/"}]},{"title":"邮箱消息嵌入到web系统","date":"2015-10-10T09:19:41.000Z","path":"2015/10/10/邮箱消息嵌入到web系统/","text":"需求用户邮箱（企业邮箱）作为web系统用户标识，监控用户邮箱新邮件，转换为系统消息。 难点 其实也没啥难点，只是乍一看可能会转不过来 由于企业邮箱非web系统可以控制，网上亦有多人遇此需求而无方案，故而提出鄙人方案。 遇此需求，脑中闪现出第一方案，单独配置一个服务，每隔一段时间遍历所有用户邮箱，查看是否有新消息，如有则在消息表中生成数据，web平台根据新数据进行展示。缺点：用户数目过多时，压力过大，且邮箱中新邮件的频率不是特别大，故而没必要隔段时间遍历，且实现复杂。 方案 部署单独服务（非必要），创建用户填写邮箱授权的页面，编写接口进行对单个用户邮箱进行查询。 触发此服务，web平台每隔一段时间，触发1中接口。 如有新邮件，则在消息表中增加数据。 web平台自有消息提醒。 关于如何通过java进行邮箱访问，请自行研究。 最后请大家平时注重方案的构建能力，此方案思考用时半工作日，编码测试半工作日，不要因直观不能实现就轻易说 no I cant，甚至理直气壮的说“不能实现”。","tags":[{"name":"mail","slug":"mail","permalink":"http://yoursite.com/tags/mail/"},{"name":"邮箱消息","slug":"邮箱消息","permalink":"http://yoursite.com/tags/邮箱消息/"}]},{"title":"文档在线预览方案","date":"2015-10-05T02:33:49.000Z","path":"2015/10/05/文档在线预览方案/","text":"效果如word文档在线预览，转换为html进行展示。 方案poi不到万不得已不建议使用，很难转换完美。 七牛 七牛第三方文档转换服务，收费，但不高，api不易懂。 七牛自带转换服务。参考http://developer.qiniu.com/docs/v6/api/reference/fop/odconv.html。在文档url后拼接 ?odconv/pdf 。缺点：此api在七牛官网无入口，可能是七牛即将弃用的服务，毕竟有了收费的第三方文档服务。 某些专做文档服务的服务商 譬如idocv，其为了销售开放了试用接口http://api.idocv.com/view/url?url=，幸甚使用此接口免费，正好符合需求。 缺点： 1，数据（文档）安全性。 2，如过多调用，会引起对方警觉，可能屏蔽ip。 其他网上方案： activexobject，此js对象仅支持ie浏览器，且需要用户在浏览器上设置诸多选项。 百度文库。百度要求文档必须上传到文库。 其他方案已忘记，要么是系统局限，要么是操作繁琐，总之弃用。 根据2、3得到的html，可通过iframe进行展示。","tags":[{"name":"word在线预览","slug":"word在线预览","permalink":"http://yoursite.com/tags/word在线预览/"}]},{"title":"人才短租模式思考","date":"2015-09-24T07:52:28.000Z","path":"2015/09/24/人才短租模式思考/","text":"想法起因 企业通过猎头招到的人，留职时间约一年（cison说，只能保障渡过试用期）。那么企业会觉不爽，体验变差。 当下互联网盛行，人才思变，很难留职2年以上，一旦离职，个人信用值会降低，不离职，心中难受。 解决办法构建人才短租模式 对于企业来说，期望人才留职3年以上，但基本不可能，且猎头费依旧高昂。短租模式根据人才租约时间制定猎头费用，企业心理承受会好一些。 对于中高端人才来说，基本只有猎头+内推方式换工作。通过猎头跳槽，心理预期也就是工作一年，期满再跳，不必担心个人信誉负担。 总结起来一句话：窗户纸捅破，你究竟能接受多长时间。根据时长确定薪金与猎头服务费。 产品玩法 依旧猎头模式。 每个猎头手里有聊过的人才（能确定接受租约时长）。 人才与平台签约。 问题与挑战 通过猎头入职人才的留职时间须调研。 企业与人才对此模式的认可度，或曰企业与人才对此模式的接受时长。 标准的建立。毕竟有越俎代庖嫌疑。 愿景 弱化企业-员工的概念，就像uber要弱化汽车所有权的概念一样。","tags":[{"name":"思考","slug":"思考","permalink":"http://yoursite.com/tags/思考/"}]},{"title":"api接口规则","date":"2015-05-16T08:07:48.000Z","path":"2015/05/16/api接口规则/","text":"如想看如何防刷请求，请看【防刷】header12345678910\"client\":&#123; \"appnm\" : \"XXX\", （app name） \"appVer\" : \"1.0.0\", （app版本） \"clientType\" : \"ios\", （系统类型） \"os\" : \"iPhone OS 10.0.3\",（系统版本） \"model\" : \"iPhone Simulator\",（手机型号） \"screen\" : \"320x568\",（屏幕分辨） \"channel\" : \"app_store\", \"deviceid\" : \"E96B0235-F60C-49F4-B2F9-F1B1041C7E51\"（设备号）&#125; 123456\"auth\":&#123; \"auth\": \"audbbiuf7q74asdh8fa0s9dqjashdugfasd\",（用户唯一标识，如有则认为已登录） \"sign\": \"fad22321acbd122121\", （签名） \"ts\" : \"1231231283213\"（时间戳） \"rand\" : \"12121212\"（一个随机数）&#125; url签名可随意定义，别都是MD5sign = MD5 ( url + ts + &quot;自定义一个key&quot; + rand ) 服务端每次请求必须校验sign 备注 移动端与服务端交互的每个请求，header必须加上client\\auth中参数。 接口服务端返回为json类型，为方便移动端，json中数据类型全部为string。 如果sign不正确，服务端不处理该请求，直接返回错误码。 防刷： 校验sign，hack看到有ts，可能以为每次请求更换ts即可，实则不然，sign的算法里还有个自定义的key，如此sign很难正确。 如对方使用与上一次请求相同的sign，sign正确则url、ts、rand都与上一次相同。此时服务端开辟一个LRU缓存，对请求进行是否重复的判断。map.get(k)是否有值，如有，则为重复请求，返回错误码。我的k：url + ts + rand; 短板：在访问量超大的情况下，ts必定重复（毫秒），rd也可能重复，此时只能建议用多个rand来去重，用以保障请求的唯一性。 短板：且这个LRU缓存会越来越臃肿。所以，建议对不同的url，开辟不同的缓存。","tags":[{"name":"app","slug":"app","permalink":"http://yoursite.com/tags/app/"},{"name":"api","slug":"api","permalink":"http://yoursite.com/tags/api/"},{"name":"接口规则","slug":"接口规则","permalink":"http://yoursite.com/tags/接口规则/"}]},{"title":"app会话方案","date":"2015-05-16T08:04:45.000Z","path":"2015/05/16/app会话方案/","text":"与web开发不同点 web中有浏览器角色，保持用户登录状态可以根据cookie、sessionid等策略来实现。 而app不能（或不方便、不能自定义内容），开发者需要进行面向app的模拟session实现。 借助工具 memcached\\redis或其他进程外缓存。 实现过程 在db中创建auth表，须包含字段：id , userid(或mobile), auth , createtime。 注册时，user表中添加数据后，auth表中也添加记录，auth可自行选择加密方案。 登录时： 1，user表中查找成功。 2，服务端从db中获取auth，放入缓存中。 3，将auth返回给移动端。 移动端每次请求服务端，均须将auth信息放入header中。服务端在拦截器中校验auth（先从缓存中取，如无则取db，然后放入缓存）是否正确、定位是哪个用户。 注释 web中默认未登录状态。移动端默认为登录状态（每次打开app只要有auth信息就默认为登录）。 在缓存中，auth要设有效时长。 缓存中的数据结构为 auth:userid(mobile)。 当下多数app将注册与登录合二为一，使用手机号+短信验证码实现注册即登录，此时实现方案应相应作出修改，在此不述。 web开发也可类似上述方案进行开发，不使用httpsession，原因不述。","tags":[{"name":"app","slug":"app","permalink":"http://yoursite.com/tags/app/"},{"name":"auth","slug":"auth","permalink":"http://yoursite.com/tags/auth/"}]},{"title":"算法夕拾（09）--冒泡","date":"2014-10-21T19:04:30.000Z","path":"2014/10/22/算法夕拾（09）-冒泡/","text":"原理两两比对，调整顺序，比较n-1次 实现123456789101112131415public static void sort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &lt; arr[j + 1]) &#123; int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 复杂度时间：O(n2) 空间：O(1)","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"算法夕拾（08）--桶排序","date":"2014-10-21T18:42:11.000Z","path":"2014/10/22/算法夕拾（08）-桶排序/","text":"原理 事先准备N个桶，每个桶代表从1到N的值。 将N-1个待排序数字，按照N桶的数字进行放入。 相同的桶放入了n次相同数字，则相应的桶的值为n。 遍历N个桶，只要桶中的值大于0，则输出序号，值为2，则输出两次该序号。 代码 123456789101112131415161718192021/** * 桶排序 */public static void sort(int[] array, int range) &#123; // 桶 int[] bucket = new int[range]; // 遍历array，向bucket中表示 for (int i = 0; i &lt; array.length; i++) &#123; int index = array[i]; bucket[index] = bucket[index] + 1; &#125; // 输出 for (int i = 0; i &lt; bucket.length; i++) &#123; for (int j = 0; j &lt; bucket[i]; j++) &#123; System.out.println(i); &#125; &#125;&#125; 结论桶排序实际上只需要遍历一遍所有的元素，然后依次放入制定的位置。如果加上输出排序的时间，那么时间复杂度为O(n+m)，n：待排序的元素个数，m：桶的个数。很快，但是空间消耗比较大。 元素跨度越大，空间消耗越大，空间利用率越低，浪费越大。 但是 快 ！ 适用场景数据分布相对均匀，跨度不太大的场景。 改进利用类似散列表的方式，改善空间利用率。","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"算法夕拾（07）--链表","date":"2014-10-19T06:31:22.000Z","path":"2014/10/19/算法夕拾（07）-链表/","text":"何谓链表 在物理存储上非连续、非顺序的存储结构。 数据之间通过指针关联。 data（数据）、next（指针） 特点 物理空间不连续，内存开销较大（存储指针）。 无容量限制。 查找元素需要顺序遍历。 操作复杂。 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package linkedlist;/** * 链表实现 */public class LinkedList &#123; public Node head = null; // 头节点 public Node tail = null; // 尾节点 public int size = 0; // 头插入 public boolean insertHead(Object data) &#123; if (size == 0) &#123; initial(data); &#125; else &#123; Node node = new Node(data); node.setNext(head); head = node; &#125; size++; return true; &#125; // 尾插入 public boolean insertTail(Object data) &#123; if (size == 0) &#123; initial(data); &#125; else &#123; Node node = new Node(data); tail.setNext(node); tail = node; &#125; size++; return true; &#125; // 中间插入,插入到index的后面 public boolean insertAfter(int index, Object data) throws Exception &#123; if (index &gt; size) &#123; insertTail(data); &#125; else &#123; if (index == 0) &#123; insertHead(data); &#125; else &#123; // 获得index对应的node Node indexNode = getByIndex(index); Node node = new Node(data); node.setNext(indexNode.getNext()); indexNode.setNext(node); size++; &#125; &#125; return true; &#125; // 头删除 public boolean removeHead() throws Exception &#123; if (size == 0) &#123; throw new Exception(\"likedlist is empty , can not remove head node\"); &#125; head.setData(head.getNext().getData()); head.setNext(head.getNext().getNext()); size--; return true; &#125; // 尾删除 public boolean removeTail() throws Exception &#123; if (size == 0) &#123; throw new Exception(\"likedlist is empty , can not remove tail node\"); &#125; size--; Node newTail = getByIndex(size); newTail.setNext(null); return true; &#125; // 中间删除 public boolean removeIndex(int index) throws Exception &#123; if (size == 0) &#123; throw new Exception(\"likedlist is empty , can not remove any node\"); &#125; Node indexNode = getByIndex(index); indexNode.setData(indexNode.getNext().getData()); indexNode.setNext(indexNode.getNext().getNext()); size--; return true; &#125; // 查找 public Node getByIndex(int index) throws Exception &#123; if (index &gt; size) &#123; throw new Exception(\"list is out by index \" + index); &#125; Node result = head; for (int i = 2; i &lt;= index; i++) &#123; result = result.getNext(); &#125; return result; &#125; // 初始化第一个元素 public void initial(Object data) &#123; Node n = new Node(data); head = n; tail = n; &#125; //遍历 public void traverse() &#123; Node tmp = head; while (tmp != null) &#123; System.out.println(tmp.getData()); tmp = tmp.getNext(); &#125; &#125; // 反转 public void reverse() &#123; Node tmp = head; Node tmp1 = tmp.getNext(); for (int i = 0; i &lt; size - 1; i++) &#123; Node tmp2 = tmp1.getNext(); tmp1.setNext(tmp); tmp = tmp1; tmp1 = tmp2; &#125; head.setNext(null); head = tmp; &#125;&#125;// 节点class Node &#123; private Object data; private Node next; public Node() &#123; &#125; public Node(Object data) &#123; super(); this.data = data; &#125; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"算法夕拾（06）--用队列实现栈","date":"2014-10-18T18:36:05.000Z","path":"2014/10/19/算法夕拾（06）-用队列实现栈/","text":"方案 声明两个队列 入栈：向非空队列中put元素，如都为空，则随便选。 出栈：将非空中的lenth-1个元素put到另外一个队列中，出队最后一个元素。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package queue2stack;import Queue.Queue;/** * 队列实现栈，可扩容 * * @author jack * 2016年11月19日 上午2:52:04 */public class Stack &#123; private Queue q1; private Queue q2; private int cap = 10; public Stack(int cap) &#123; super(); this.cap = cap; this.q1 = new Queue(cap + 1); this.q2 = new Queue(cap + 1); &#125; // 入栈 public boolean push(Object o) throws Exception &#123; Queue q; if (q1.isEmpty()) &#123; q = q1; &#125; q = q2; if (q.isFull()) &#123; expand(); &#125; q = q2; return q.put(o); &#125; // 出栈 public Object pop() throws Exception &#123; Queue from; Queue to; if (!q1.isEmpty()) &#123; from = q1; to = q2; &#125; else &#123; from = q2; to = q1; &#125; queueTransExceptOne(from, to); return from.poll(); &#125; // 扩容 private void expand() throws Exception &#123; this.cap = this.cap * 2 + 1; Queue q3 = new Queue(this.cap); Queue q4 = new Queue(this.cap); queueTrans(q1, q3); queueTrans(q2, q4); q1 = q3; q2 = q4; &#125; private void queueTransExceptOne(Queue queue1, Queue queue2) throws Exception &#123; while (queue1.getSize() &gt; 1) &#123; queue2.put(queue1.poll()); &#125; &#125; private void queueTrans(Queue queue1, Queue queue2) throws Exception &#123; while (!queue1.isEmpty()) &#123; queue2.put(queue1.poll()); &#125; &#125;&#125; 测试 1234567891011121314151617181920212223242526272829303132333435363738394041package queue2stack;import queue2stack.Stack;/** * * @author jack * 2016年11月19日 上午3:03:57 */public class Test &#123; public static void main(String[] args) &#123; Stack stack = new Stack(5); for (int i = 0; i &lt; 15; i++) &#123; try &#123; stack.push(i + \"\"); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; for (int i = 0; i &lt; 15; i++) &#123; try &#123; System.out.println(stack.pop()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; try &#123; System.out.println(stack.pop()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;// System.out.println(stack.s); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"算法夕拾（05）--用栈实现队列","date":"2014-10-18T18:05:41.000Z","path":"2014/10/19/算法夕拾（05）-用栈实现队列/","text":"用栈实现队列方案1此方案较为繁琐。 声明两个栈A,B。 队列put：将A中的所有元素压入B中，向A中压入元素，将B中所有元素压回。 队列poll：将A中元素全部压入B，B出栈。 方案2 申明两个栈A,B。A专职入队，B专职出队。 队列put：向A中压入元素。 队列poll：如B中有，则B出栈。如果B为空，则将A中元素全部压入B，然后B中出栈。 实现（方案2）12345678910111213141516171819202122232425262728293031323334353637383940package stack2queue;import stack.Stack;/** * @author jack * 2016年11月19日 上午2:20:25 */public class Queue &#123; private Stack s1; // 专门入栈 private Stack s2; // 专门出栈 public Queue(int cap) &#123; super(); this.s1 = new Stack(cap); this.s2 = new Stack(cap); &#125; // 入队 public boolean put(Object o) &#123; return s1.push(o); &#125; // 出队 public Object poll() throws Exception &#123; if (s2.isEmpty()) &#123; stackTrans(s1, s2); &#125; return s2.pop(); &#125; // 栈之间全拷贝 private void stackTrans(Stack stack1, Stack stack2) throws Exception &#123; while (!stack1.isEmpty()) &#123; Object o = stack1.pop(); stack2.push(o); &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"算法夕拾（04）--队列","date":"2014-10-18T17:29:15.000Z","path":"2014/10/19/算法夕拾（04）-队列/","text":"队列特点 一段连续的内存空间（存疑） 先进先出 put（入队）、poll（出队） 可由数组、链表实现 顺序队列、循环队列 head(头) , tail(尾) 顺序队列会造成“假上溢”（head已经poll之后，再put时却无法使用原head位置的内存），于是应使用循环队列 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Queue;/** * * * @author jack * 2016年11月19日 上午1:37:17 */public class Queue &#123; // h t // [0,1,2,3,4] private Object[] arr; int head = 0; int tail = 0; // tail处不存储元素 public Queue(int cap) &#123; arr = new Object[cap]; &#125; // 入队 public boolean put(Object object) throws Exception &#123; if (isFull()) &#123; throw new Exception(\"The queue is full now\"); &#125; arr[tail] = object; tail = (tail + 1) % arr.length; return true; &#125; // 出队 public Object poll() throws Exception &#123; if (isEmpty()) &#123; throw new Exception(\"The queue is empty now\"); &#125; Object result = arr[head]; head = (head + 1) % arr.length; return result; &#125; // 判断是否满 public boolean isFull() &#123; return head == (tail + 1) % arr.length; &#125; // 判断是否空 public boolean isEmpty() &#123; return head == tail; &#125; // 获得队顶元素&#125;","tags":[{"name":"存疑","slug":"存疑","permalink":"http://yoursite.com/tags/存疑/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"算法夕拾（03）--栈","date":"2014-10-17T16:50:26.000Z","path":"2014/10/18/算法夕拾（03）-栈/","text":"栈的特点 一段连续的内存空间 先进后出 push（进栈）、pop（出栈） 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package stack;import java.util.Arrays;/** * 栈的定义 * * @author jack * 2016-11-18 上午12:56:22 */public class Stack &#123; private int cap = 10; // 数组长度 private int size = 0; // 已经使用长度 private Object[] arr; // 存储 // 构造器 public Stack(int cap) &#123; super(); this.cap = cap; arr = new Object[cap]; &#125; // 入栈，考虑扩容 public boolean push(Object object) &#123; // 扩容 if (isFull()) &#123; expand(); &#125; //添加元素 arr[size ++] = object; return true; &#125; // 出栈 public Object pop() throws Exception&#123; if(isEmpty())&#123; throw new Exception(\"No ele in this stack\"); &#125; Object result = getTop(); size-- ; return result; &#125; // 栈顶元素 public Object getTop()&#123; return arr[size - 1]; &#125; // 判断是否满 public boolean isFull() &#123; return size == cap; &#125; // 判断是否空 public boolean isEmpty() &#123; return size == 0; &#125; // 扩容 private void expand() &#123; cap = cap * 2; arr = Arrays.copyOf(arr, cap); &#125;&#125; 12345678910111213141516171819202122232425262728293031package stack;/** * @author jack * 2016-11-18 上午1:08:53 */public class Test &#123; public static void main(String[] args) &#123; Stack stack = new Stack(5); for (int i = 0; i &lt; 15; i++) &#123; stack.push(i + \"\"); &#125; for (int i = 0; i &lt; 15; i++) &#123; try &#123; System.out.println(stack.pop()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; try &#123; System.out.println(stack.pop()); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 使用场景 逆序输出。 语法检查：凡是遇到“（”则入栈，只要遇到“）”就对比栈顶元素是否与之对应。 数制转换。 数制转换： 123456题目：十进制100转换为8进制解法： 将 100 ➗ 8 = 12 余 4，将4压入栈。 将 12 ➗ 8 = 1 余 4 , 将4压入栈 。 1 压入栈 出栈：144结果： 144","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"算法夕拾（02）--集合、散列表","date":"2014-10-17T15:56:30.000Z","path":"2014/10/17/算法夕拾（02）-集合/","text":"何谓集合 基于数组的拓展，无长度限制。 列表：有序集合。链表、队列、栈。使用数组实现。 集：无序、数据不能重复。使用散列表实现。 多重集：无序、数据可重复。可通过排序转换为列表。（不知道是什么鬼，没用过） 数、图：略。 列表特点（变长数组） 变长。在不够长的时候通过数组拷贝的方式创建新数组。 拷贝的方式会造成性能耗损。 查询欠佳。 查询、修改的时间复杂度为O(n)。 查找顺序存储的结构类型，在数据量大的情况下，依旧是从0开始，一个个的去访问。效率很低。 何谓散列表 又称“哈希表”，能够通过key直接访问到具体元素。通过key访问一个映射表来得到value的地址。这个映射表也称为“散列函数”或者“哈希函数”。存放记录的数组叫做“散列表”。 通过不同的key，可能映射到相同的地址，这种现象叫做 “碰撞” 。 散列表有两种用法，一种是k=v，即set。另一种即map。 哈希函数的实现考虑因素：关键字的长度、哈希表的大小、关键字的分布情况、记录的查找频率等 直接寻址法：取关键字或者关键字的某个线性函数值作为散列地址。 数字分析法：通过对数据的分析，发现冲突较小的部分，构造散列地址。 取随机数法：取关键字的随机值作为散列地址。适用于关键字长度不一致的情况。 哈希函数冲突处理对不同的key进行hash运算，可能会出现相同的结果。处理如下： 开放地址法： 简单地讲，也就是说，一间厕所，来了一个顾客就蹲其对应的位置，如果又来一个顾客，把厕所单间门拉开，一看里面有位童鞋正在用劲，那么怎么办？很自然的，拉另一个单间的门，看看有人不，有的话就继续找坑。当然了，一般来说，这个顾客不会按顺序一个一个地拉厕所门，而是会去拉他认为有可能没有被占用的单间的门，这可以通过闻味道，听声音来辨别，这就是寻址查找算法。 再哈希法：产生冲突后使用关键字的其他部分再次进行计算取址，如还是冲突则再用其它的部分hash。缺点：时间增加了。 链地址法：在地址上做一个链表，存储。 公共溢出区：建立一个公共溢出区。 散列表存储结构 一个好的散列设计，除了一个良好的hash函数外，还要有好的冲突处理方式。一般选择链地址法。 数组 + 链表 散列表的特点 访问速度快：通过散列函数将key指定到一个地址上，所以在访问的时候不需要一个一个查找。增删改查都很快。（！！！！存疑，hash方法到底是得到一个数组index还是内存地址） 需要额外的空间：散列表实际上不太可能满载；额外空间处理冲突。 无序。 可能会产生碰撞，使得散列复杂。 数据量大（map快满载）时，性能下降。（冲突太多，在链表中太麻烦） 散列表的适用场景适合无序的，需要快速访问的情况。 缓存。 快速查找。判断set中是否存在某指定元素 散列表性能分析 如果没有冲突，通过对key进行hash寻址，完全是O(1)的效率，但是冲突在所难免。通常使用链地址法来处理冲突。碰撞之后需要遍历链表，时间复杂度为O(L)，L为链表长度。 当map负载很大的时候，说明大部分地址已经有值了，此时再添加元素，势必碰撞，势必走链表，于是性能下降。此时应当扩容，java的hashMap扩容因子为0.75，当负载达到75%的时候进行扩容。扩容之后进行大排版，也许之前在链表中存储，现在在数组中存储。","tags":[{"name":"存疑","slug":"存疑","permalink":"http://yoursite.com/tags/存疑/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"算法夕拾（01）--数组","date":"2014-10-16T14:38:11.000Z","path":"2014/10/16/算法夕拾（01）-数组/","text":"何谓数组 将 有限个同类型 的元素放在地址连续的内存中，以一个变量命名，通过序号进行访问指定元素。 使用前需要预估好长度，数组不能动态增长或者缩小。有余则费，不足无奈。 存储结构 确定一个值作为长度length。 根据声明的数据类型开辟内存空间（不同类型开辟的空间也不同）。 对内存空间的每一个元素都赋默认值。 初始化1int[] num = new int[10]; //每个值都为0 1234int[] num = new int[10];num[0] = 1;num[1] = 2;num[2] = 3; //部分初始化 1int[] num = &#123;1, 2, 3&#125; //显示初始化 1num.length; //length属性 特点 长度固定。如果还想继续添加元素，只能另创一个数组。 顺序访问。必须从第1个元素开始访问，虽然编程中可以通过下标指定元素，但计算机在处理时还是顺序访问。 适用场景由于长度固定，所以适用于不会变化的业务。","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"mac os 配置maven","date":"2014-07-16T08:29:03.000Z","path":"2014/07/16/mac-os-配置maven/","text":"下载mavenhttp://maven.apache.org/download.cgi 解压解压到 /usr/local 重命名为maven 新建（如无）.bash_profile编辑内容： 1234567891011JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/HomeM3_HOME=/usr/local/maven3PATH=$M3_HOME/bin:$PATHexport JAVA_HOMEexport M3_HOMEexport PATH 测试mvn -version 如未生效source .bash_profile 使之生效","tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]}]